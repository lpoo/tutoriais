\documentclass[letterpaper,11pt]{article}
\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage{ae}
\usepackage[utf8]{inputenc}
\usepackage[dvipsnames]{color}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{multirow}
\usepackage{amssymb, amsmath, amsfonts}
\bibliographystyle{plain}
\topmargin		0 cm
\hoffset		0 cm
\voffset		0 cm
\evensidemargin		0 cm
\oddsidemargin		0 cm
\setlength{\textwidth}{16 cm}
\setlength{\textheight}{21 cm}
\usepackage{pnl}

\title{Apostila de Instalação do CUTEr}
\author{Abel Soares Siqueira}

\numberwithin{equation}{section}

% \newcommand{\visiblelbl}[1]{\label{#1}{\color{red}{#1}}}
\newcommand{\visiblelbl}[1]{\label{#1}}

\begin{document}
\maketitle

A biblioteca CUTEr (\cite{bib:cuter1,bib:cuter2}) é de extrema importância para a
realização de testes computacionais na área de otimização computacional. 
Tendo em vista que é necessário fazer comparações entre os algoritmos,
Muitos deles atualmente têm uma interface que permite a execução dos testes
do CUTEr. Vamos mostrar nesse tutorial como instalar o CUTEr e criar uma interface
em Fortran, C e C++ para o mesmo. Algumas partes deste tutorial supõem que o leitor
saiba o suficiente de linux.

\section{Instalação}

O CUTEr é um ambiente de testes para métodos de otimização. 
Ele foi feito em Fortran, porém tem suporte a C/C++.
Para instalar o CUTEr você irá precisar dos programas:
\begin{itemize}
 \item gawk 
 \item gcc 
 \item gfortran (ou outro compilador de fortran)
 \item svn (subversion)
\end{itemize}
Com os pacotes instalados, iremos criar uma pasta para o CUTEr. Você pode criar uma
pasta separada no sistema ou instalar tudo no seu diretório principal. No meu caso,
irei criar uma pasta chamada \verb+libraries+ na minha pasta pessoal, e criar uma
pasta para o CUTEr dentro dessa pasta. Ajuste os comandos de acordo com sua escolha.
  \begin{terminal}
$ mkdir -p $HOME/libraries/CUTEr
$ cd $HOME/libraries/CUTEr
\end{terminal}
Agora faça o download do SifDec2 pelo comando a seguir
\small
\begin{terminal}
$ svn co http://tracsvn.mathappl.polymtl.ca/SVN/cuter/sifdec/branches/SifDec2 ./sifdec2
\end{terminal}
E você precisa baixar o CUTEr2 agora. Se quiser a versão 32 bits:
\begin{terminal}
$ svn co http://tracsvn.mathappl.polymtl.ca/SVN/cuter/cuter/branches/CUTEr2 ./cuter2
\end{terminal}
E a versão 64 bits:
\begin{terminal}
$ svn co http://tracsvn.mathappl.polymtl.ca/SVN/cuter/cuter/branches/CUTEr64 ./cuter2
\end{terminal}
\normalsize
Faça o download da coleção de problemas SIF na página
\begin{verbatim}
http://cuter.rl.ac.uk/cuter-www/Problems/mastsif.shtml
\end{verbatim}
ou use os comandos
\begin{terminal}
$ wget ftp://ftp.numerical.rl.ac.uk/pub/cuter/mastsif_small.tar.gz 
$ wget ftp://ftp.numerical.rl.ac.uk/pub/cuter/mastsif_large.tar.gz
\end{terminal}
Descompacte os problemas pequenos com o comando
\begin{terminal}
$ tar -zxvf mastsif_small.tar.gz 
\end{terminal}
Se quiser, descompacte os problemas grandes também. Note que estes problemas são
muito mais pesados que os pequenos, então aconselho baixá-los apenas se for necessário.
\begin{terminal}
$ tar -zxvf mastsif_large.tar.gz
\end{terminal}
Iremos começar a instalar o CUTEr. Para isso, vamos instalar o decodificador
dos problemas SIF (que faz parte da biblioteca CUTEr).
Entre na pasta \verb+sifdec2+ criada em \verb+$HOME/libraries/CUTEr+.
\begin{terminal}
$ cd $HOME/libraries/CUTEr/sifdec2
\end{terminal}
Agora digite o comando
\begin{terminal}
$ ./install_sifdec
\end{terminal}
A instalação do sifdec irá pedir que você escolha
\begin{itemize}
 \item Plataforma (no nosso caso será 5 - PC)
 \item Sistema Operacional (no nosso caso será 2 - linux)
 \item Compilador Fortran (no nosso caso será 7 - GNU gfortran)
 \item Precisão (no nosso caso será D - double)
 \item Tamanho (no nosso caso será L - large, porém pode ser necessário mudar para C - custom,
dependendo do software e dos testes que você utilizará. Nesse caso edite o arquivo na pasta
\verb+build/arch/size.custom+ antes de continuar.)
\end{itemize}
O instalador vai lançar a mensagem
\begin{terminal}
 By default, SifDec with your selections will be installed in
  /home/abel/libraries/CUTEr/sifdec2/SifDec.large.pc.lnx.gfo
 Is this OK (Y/n)?
\end{terminal}
Anote o nome do diretório que será criado e aperte enter. No nosso caso, será \\
 \verb+SifDec.large.pc.lnx.gfo+. Para a próxima mensagem, escreva `n' e aperte enter.

Agora vamos acrescentar as variáveis de sistema para que o instalador e os softwares
que formos utilizar saibam onde está o CUTEr. Edite o arquivo \verb+$HOME/.bashrc+ e
adicione as seguintes linhas
\begin{terminal}
ROOTCUTER="$HOME/libraries/CUTEr"
export CUTER="$ROOTCUTER/cuter2"
export MYCUTER="$CUTER/CUTEr.large.pc.lnx.gfo" 
export SIFDEC="$ROOTCUTER/sifdec2"
export MYSIFDEC="$SIFDEC/SifDec.large.pc.lnx.gfo" 
export MASTSIF="$ROOTCUTER/mastsif" 
export MANPATH="$CUTER/common/man:$SIFDEC/common/man:$MANPATH" 
export PATH="$MYCUTER/bin:$MYSIFDEC/bin:$PATH"
\end{terminal}
Se for necessário, mude a variável \verb+ROOTCUTER+, e o diretório que eu mandei anotar. 
Note que já criamos um diretório para o CUTEr, supondo que ele siga as mesmas opções
que o SifDec. 
Para que essas mudanças façam efeito é necessário usar o comando
\begin{terminal}
$ source $HOME/.bashrc
\end{terminal}
ou reiniciar o terminal.
Agora entre na pasta que criamos anteriormente. Para isso basta fazer
\begin{terminal}
$ cd $MYSIFDEC
\end{terminal}
Se deu algum erro, você pode ter errado o nome na definição da variável. Verifique que a
pasta realmente existe e refaça os passos se necessário.

Agora rode o comando
\begin{terminal}
$ ./install_mysifdec
\end{terminal}
Ao final desse comando, a frase
\begin{terminal}
install_mysifdec : Do you want to 'make all' in
 /home/abel/libraries/CUTEr/sifdec2/SifDec.large.pc.lnx.gfo now (Y/n)?
\end{terminal}
aparecerá. Aperte enter. Agora vamos instalar o CUTEr. Para isso, faça
\begin{terminal}
$ cd $CUTER
$ ./install_cuter
\end{terminal}
A instalação do cuter irá pedir que você escolha
\begin{itemize}
 \item Plataforma (no nosso caso será 5 - PC)
 \item Sistema Operacional (no nosso caso será 2 - linux)
 \item Compilador Fortran (no nosso caso será 7 - GNU gfortran)
 \item Compilador C (no nosso caso será 4 - g++)
 \item Precisão (no nosso caso será D - double)
 \item Tamanho (no nosso caso será L - large, com a mesma observação sobre o tamanho.)
\end{itemize}
Quando necessário, aperte enter para confirmar a continuação do programa. Se tudo deu
certo, o CUTEr deve estar instalado. Caso tenha acontecido algum erro, reveja as variáveis
e volte os passos. Pode ser necessário apagar tudo que você baixou e baixar novamente (em 
último caso). Para verificar que realmente está tudo funcionando, faça
\begin{terminal}
$ mkdir -p $HOME/libraries/CUTEr/Testing
$ cd $HOME/libraries/CUTEr/Testing
$ runcuter -p gen -D ROSENBR
\end{terminal}
Se nenhum erro aparecer, e aparecer várias informações do problema, então o
CUTEr foi instalado corretamente.

\section{Interface}

A biblioteca CUTEr dá ao usuário um conjunto de funções para receber informações do problema.
As funções são separadas para o caso irrestrito (precedidas pela letra \emph{U}) ou
restrito, (precedidas pela letra \emph{C}). Se o usuário necessitar do valor da funcão
 objetivo num ponto dado, ele pode chamar \verb+UFN+ se o problema for irrestrito, ou
\verb+CFN+ caso contrário. Note que a sintaxe das funções não é a mesma, pois o CUTEr tenta
ser o mais prático possível. A sintaxe dessas funcões é
\begin{itemize}
 \item \verb+UFN (N, X, F)+, onde \verb+N+ é um inteiro indicando o número de 
variáveis do problema, \verb+X+ é um vetor de
reais, e \verb+F+ é real que sai com o valor da função objetivo.
 \item \verb+CFN (N, M, X, F, LC, C)+, onde \verb+N+,\verb+X+ e \verb+F+ indicam as
mesmas coisas, \verb+M+ é um inteiro indicando o número de restrições, \verb+C+ é um
vetor de reais, com os valores das restrições e \verb+LC+ é a dimensão real de \verb+C+,
que deve ser maior ou igual a \verb+M+.
\end{itemize}
Existem muitas outras funções para interação com o problema. Elas podem ser vistas na
documentação do CUTEr no arquivo \verb+general.pdf+ dentro da pasta
\verb+$CUTER/common/doc+ nas páginas 31 e 32.

Para rodar nossa biblioteca com o CUTEr, é necessário criar alguns arquivos extras.
Um deles é o código que relaciona o nosso programa com essas funções do CUTEr. Além disso,
também é necessário criar um arquivo que indica ao CUTEr quais as bibliotecas que nossa
biblioteca precisa. A maneira tradicional de se trabalhar com o CUTEr (o novo CUTEr, pelo
menos) é compilar nossa biblioteca inteira para um arquivo .a, compilar esse arquivo de
ligação do CUTEr com nossa biblioteca, e passar tudo isso pro CUTEr. Quando necessário,
rodamos o nosso pacote pelo comando do CUTEr \verb+runcuter+. Por exemplo, para rodar o
pacote \verb+pack_exemplo+, usamos o comandos
\begin{terminal}
$ runcuter -p pack_exemplo -D problema
\end{terminal}
onde \verb+problema+ é um dos problemas do CUTEr sem a extensão \verb+.SIF+.

\subsection{Instalação da interface}

\section{Exemplos}

Como exemplos do CUTEr, vamos criar bibliotecas em diversas linguagens para resolver o 
problema de minimização irrestrita. 
Vamos implementar o método de máxima descida com busca linear utilizando o
critério de Armijo.

Considere o problema
\begin{equation}
 \min f(x), \qquad x \in \Rn{n},
\end{equation}
onde $f:\RnemR{n}$ é contínua e derivável. Vamos procurar um ponto estacionário para esse
problema, isto é, um ponto $x^* \in \Rn{n}$ tal que $$\nabla f(x^*) = 0.$$
Obviamente, como vamos implementar este método, vamos parar quando encontrarmos um
iterando $x^k$ tal que $\norma{\nabla f(x^k)} \leq \varepsilon,$ onde $\varepsilon > 0$ é
dado. O método está descrito a seguir.
\begin{algorithm}
 \item Dados $x^0 \in \Rn{n}$, $\varepsilon > 0$, $\alpha \in (0,1)$, $k = 0$.
 \item Enquanto $\norma{\nabla f(x^k)} > \varepsilon$ faça
 \begin{algorithm} 
  \item $d^k = -\nabla f(x^k)$
  \item $\lambda_k = 1$
  \item Enquanto $f(x^k + \lambda_kd^k) > f(x^k) + \alpha \lambda_k \nabla f(x^k)^Td^k$ faça
  \begin{algorithm}
   \item $\lambda_k = \lambda_k/2$
  \end{algorithm}
  \item $x^{k+1} = x^k + \lambda_kd^k$
  \item $k = k + 1$
 \end{algorithm}
 \item $x^* = x^k$.
\end{algorithm}
Vamos implementar este método em algumas linguagens, e às vezes, mais de uma vezes, para
exemplificar a interface CUTEr.

\subsection{Exemplos em Fortran}

Está faltando

\subsection{Exemplos em C}

Fizemos três implementações do método de máxima descida. A primeira é uma implementação
que não leva me conta o CUTEr, e depois adapta o CUTEr para o problema. A segunda já leva
em conta o formato das funções do CUTEr e faz pouca adaptação posteriormente. A terceira
usa exatamente as funções do CUTEr, não necessitando de adaptação.

Cada implementação do método de máxima descida consiste de dois arquivos:
\verb+steepest_descent.h+ e \verb+steepest_descent.c+. No .h, definimos que funções
iremos chamar, e uma estrutura com as informações da execução. As funções para a 
primeira implementação são
\begin{itemize}
 \item \verb+double Norm (double * x, unsigned int n);+ \\
Esta função calcula a norma 2 de um vetor \verb+x+ com tamanho \verb+n+.
 \item \verb+double NormSqr (double * x, unsigned int n);+ \\
Esta função calcula o quadrado da norma 2 de um vetor \verb+x+ com tamanho \verb+n+. É mais
rápido que a função \verb+Norm+ pois não envolve raiz quadrada.
 \item \verb+SteepestDescent (double * x, unsigned int n, Status * status);+ \\
Esta é a função que encontra o ponto estacionário. \verb+x+ entra como ponto inicial e 
sai como a solução. \verb+n+ é a dimensão do problema e \verb+status+ é um ponteiro para
a estrutura de informações.
 \item \verb+SD_Print (double * x, unsigned int n, Status * status);+ \\
Esta função imprime o vetor \verb+x+ e as informações da execução do problema.
\end{itemize}
A estrutura do problema
\begin{code}{C}
typedef struct _Status {
  unsigned int iter;
  double f, ng;
  unsigned int n_objfun, n_gradfun;
} Status;
\end{code}
\verb+iter+ é o número de iterações que o algoritmo executou, \verb+f+ é o valor da
função objetivo na solução, \verb+ng+ é a norma do gradiente da função objetivo,
\verb+n_objfun+ é o número de cálculos da função objetivo e \verb+n_gradfun+ é o número
de cálculos do gradiente. Mostraremos as diferenças das outras implementações posteriormente.

Nosso arquivo .c contém as definições das funções acima, e contém uma declaração de função
usada para acessar a função objetivo e o gradiente. Na primeira implementação, essa declaração
é
\begin{code}{C}
double objfun  (double * x, unsigned int n);
void   gradfun (double * x, unsigned int n, double * g);
\end{code}
As funções \verb+Norm+, \verb+NormSqr+ e \verb+SD_print+ são idênticas para todas as
implementações e serão deixadas de fora. A implementação do método em si encontra-se abaixo.
\scriptsize
\begin{code}{C}
void SteepestDescent (double * x, uint n, Status *status) { 
  double * g, f, fp;
  double * xp, lambda, ng_sqr;
  uint i;

  if ( (x == 0) || (status == 0) )
    return;

  g  = (double *) malloc(n * sizeof(double) );
  xp = (double *) malloc(n * sizeof(double) );
  status->iter = 0;
  status->n_objfun = 0;
  status->n_gradfun = 0;

  f = objfun(x, n);
  status->n_objfun++;
  gradfun(x, n, g);
  status->n_gradfun++;

  status->ng = Norm(g, n);

  while (status->ng > EPSILON) {
    lambda = 1;

    for (i = 0; i < n; i++) {
      xp[i] = x[i] - g[i];
    }

    fp = objfun(xp, n);
    status->n_objfun++;
    ng_sqr = status->ng*status->ng;

    while (fp > f - 0.5 * lambda * ng_sqr) {
      for (i = 0; i < n; i++) {
        xp[i] = x[i] - lambda*g[i];
      }
      lambda = lambda/2;
      fp = objfun(xp, n);
      status->n_objfun++;
    }

    for (i = 0; i < n; i++)
      x[i] = xp[i];

    f = objfun(x, n);
    status->n_objfun++;
    gradfun(x, n, g);
    status->n_gradfun++;
    status->ng = Norm(g, n);
    status->iter++;
  }

  status->f = f;

  free(xp);
  free(g);
}
\end{code}
\normalsize
Um código de exemplo para esse teste é
\scriptsize
\begin{code}{C}
#include <stdio.h>
#include "steepest_descent.h"

/*
 * Each file testx.c is a different problem. The user will have to
 * implement his own file, defining objfun and gradfun.
 */

/*
 * This problem is
 *
 *  min f(x) = 0.5*(x_1^2 + x_2^2)
 *
 *  starting from point x0 = (1,2);
 *
 */

double objfun (double * x, unsigned int n) {
  (void)n;
  return 0.5 * (x[0]*x[0] + x[1]*x[1]);
}

void gradfun (double * x, unsigned int n, double * g) {
  unsigned int i;

  for (i = 0; i < n; i++)
    g[i] = x[i];
}

int main () {
  double x[2];
  Status status;

  x[0] = 1;
  x[1] = 2;

  SteepestDescent(x, 2, &status);

  SD_Print(x, 2, &status);

  return 0;
}
\end{code}
\normalsize
Este código implementa o problema de minimizar $f(x) = \meio\norma{x}^2$ em duas dimensões.
Note como temos que declarar as funções \verb+objfun+ e \verb+gradfun+. Sem elas teríamos
erros na compilação. Veja os arquivos \verb+test2.c+ e \verb+test3.c+
para outros exemplos.

A interface para o CUTEr é o arquivo \verb+c_example1main.c+:
\scriptsize
\begin{code}{C}
#include "cuter.h"
#include "CExample1/steepest_descent.h"

double objfun (double * x, unsigned int n) {
  double F = 0;
  int N = n;
  UFN(&N, x, &F);
  return F;
}

void gradfun (double * x, unsigned int n, double * g) {
  int N = n;
  UGR(&N, x, g);
}

int MAINENTRY () {
  double *x, *bl, *bu;
  char fname[10] = "OUTSDIF.d";
  int nvar = 0, ncon = 0, nmax;
  int funit = 42, ierr = 0, fout = 6;
  int i;
  Status status;

  FORTRAN_OPEN(&funit, fname, &ierr);
  CDIMEN(&funit, &nvar, &ncon);

  if (ncon > 0) {
    printf("ERROR: Problem is not unconstrained\n");
    return 1;
  }

  x  = (double *) malloc (sizeof(double) * nvar);
  bl = (double *) malloc (sizeof(double) * nvar);
  bu = (double *) malloc (sizeof(double) * nvar);

  USETUP(&funit, &fout, &nvar, x, bl, bu, &nmax);

  for (i = 0; i < nvar; i++) {
    if ( (bl[i] > -CUTE_INF) || (bu[i] < CUTE_INF) ) {
      printf("ERROR: Problem has bounds\n");
      return 1;
    }
  }

  SteepestDescent(x, nvar, &status);

  SD_Print(x, nvar, &status);

  free(x);
  free(bl);
  free(bu);

  return 0;
}
\end{code}
\normalsize
Note que também é necessário definir as funções \verb+objfun+ e \verb+gradfun+. Essas
funções, por sua vez, chamam as funções correspondentes em CUTEr para esse serviço.
A função \verb+UFN+ calcula o valor da função objetivo e a função \verb+UGR+ calcula
o valor do gradiente. Note que quando compilamos uma função em Fortran, ele recebe um
nome em letras minúsculas e com um \_ (underline) na frente (no caso do gfortran. Outros
compiladores podem divergir). O arquivo \verb+cuter.h+ define macros para todas as funções
do CUTEr serem chamados com letras maiúsculas. Note ainda que a função \verb+UFN+ recebe
um ponteiro para \verb+int+ e dois ponteiros para \verb+double+, sendo o primeiro para o
vetor $x$ e o segundo para o valor da função objetivo. As funções do CUTEr para C recebem
ponteiros em todos os valores. Os valores que são vetores não precisam de um ponteiro 
adicional. Note também que como utilizamos \verb+unsigned int+ para os tamanhos, tivemos
que converter os valores para \verb+int+.

Veja agora o Exemplo 2. Nesse exemplo consideramos que as funções devem estar no mesmo
formato que a função do CUTEr.
\begin{code}{C}
void ufn (int * n, double * x, double * f);
void uofg (int * n, double * x, double * f, double * g, long int * grad);
\end{code}
O nome das funções foram escolhidas para seguir exatamente o formato do CUTEr, mas aqui
elas poderiam ser qualquer coisa. Note que a função \verb+uofg+ foi utilizada no lugar
da função \verb+ugr+. Essa função já calcula a função objetivo e o gradiente, sendo mais
rápida que chamadas individuais. Com essa mudança, esse programa é levemente mais rápido
que o outro. O resto do arquivo foi mudado de acordo a seguir essas mudanças.

A interface também teve uma mudança na definição das funções:
\begin{code}{C}
void ufn (int * n, double * x, double * f) {
  UFN(n, x, f);
}

void uofg (int * n, double * x, double * f, double * g, long int * grad) {
  UOFG(n, x, f, g, grad);
}
\end{code}
Essa interface fica muito mais natural de ser utilizada num problema com CUTEr. Não precisamos
converter nenhuma variável, simplesmente fazer a chamada da função com os parâmetros já dados.
Note, no entanto, que estamos utilizando \verb+long int+ para as variáveis lógicas do CUTEr.
Essa é uma definição do arquivo \verb+cuter.h+. Se mudarmos essa definição, então devemos
criar uma variável \verb+logical GRAD = *grad+ e chamar a função com
\verb+UOFG(n, x, f, g, &GRAD)+.

A última interface já declara as funções que o CUTEr irá definir. Então no arquivo .c temos
\begin{code}{C}
void ufn_ (int * n, double * x, double * f);
void uofg_ (int * n, double * x, double * f, double * g, long int * grad);
\end{code}
e no arquivo da interface não temos nenhuma definição de função. Lembre-se que o Fortran
compilado com gfortran cria as funções com minúsculas e \_ na frente. Se mudarmos o
compilador pode não funcionar. 
Além disso, a definição dessas funções é, na verdade
\begin{code}{Fortran}
void UFN( integer *n, doublereal *x, doublereal *f );
void UOFG( integer *n, doublereal *x, doublereal *f, doublereal *g,
      logical *grad);
\end{code}
e esses tipos são definidos no arquivo \verb+cuter.h+, podendo ser alterados pelo usuário.
Se isso acontecer, é necessário mudar todo o programa.

Uma alternativa é utilizar \verb+typedef+s para definir os tipos próprios, e deixar o
acesso desses tipos para o usuário (assim como o arquivo \verb+cuter.h+). Dessa maneira,
se o usuário tiver necessidade de mudar o arquivo \verb+cuter.h+, ele também pode (deve)
mudar o arquivo com esses \verb+typedef+s.

Para compilar a interface CUTEr dos testes utilize
\begin{terminal}
$ make cuter
\end{terminal}
Para rodar os testes utilize o comando
\begin{terminal}
$ runcuter -p c_example# -D BARD
\end{terminal}
onde \# é o número do exemplo e BARD é um dos problemas em que esse exemplo converge. Note
que é preferível criar uma pasta separada para rodar os testes, já que eles geram lixo na
pasta.

\subsection{Exemplos em C++}

\subsection{Exemplos em Matlab}

Está faltando.

\subsection{Exemplos em Python}

Está faltando.

\begin{thebibliography}{3}
\bibitem{bib:cuter1} http://cuter.rl.ac.uk/cuter-www 
\bibitem{bib:cuter2} https://magi-trac-svn.mathappl.polymtl.ca/Trac/cuter 
\end{thebibliography}

\end{document}
